#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# AWL simulator - GUI
# Copyright 2012 Michael Buesch <m@bues.ch>
#
# Licensed under the terms of the GNU General Public License version 2.
#

import sys
import time

try:
	from PySide.QtCore import *
	from PySide.QtGui import *
except ImportError as e:
	print("PLEASE INSTALL PySide (http://www.pyside.org/)")
	input("Press enter to continue.")
	sys.exit(1)

from awlsim import *


class StateWindow(QWidget):
	closed = Signal()
	cpuStateChanged = Signal()

	def __init__(self, sim, parent=None):
		QWidget.__init__(self, parent)
		self.setLayout(QGridLayout(self))
		pixmap = QPixmap(16, 16)
		pixmap.fill(QColor(0, 0, 192))
		self.setWindowIcon(QIcon(pixmap))
		self.sim = sim

	def update(self):
		size, hint = self.size(), self.minimumSizeHint()
		if size.width() < hint.width() or\
		   size.height() < hint.height():
			self.resize(self.minimumSizeHint())

	def closeEvent(self, ev):
		self.closed.emit()
		ev.accept()

class State_CPU(StateWindow):
	def __init__(self, sim, parent=None):
		StateWindow.__init__(self, sim, parent)
		self.setWindowTitle("CPU Details")

		self.label = QLabel(self)
		font = self.label.font()
		font.setFamily("Mono")
		font.setFixedPitch(True)
		font.setKerning(False)
		self.label.setFont(font)
		self.layout().addWidget(self.label, 0, 0)

	def update(self):
		self.label.setText(str(self.sim.getCPU()))
		StateWindow.update(self)

class AbstractDisplayWidget(QWidget):
	ADDRSPACE_E		= AwlOperator.MEM_E
	ADDRSPACE_A		= AwlOperator.MEM_A
	ADDRSPACE_M		= AwlOperator.MEM_M

	addrspace2name = {
		ADDRSPACE_E	: "E",
		ADDRSPACE_A	: "A",
		ADDRSPACE_M	: "M",
	}

	changed = Signal()

	def __init__(self, sim, addrSpace, addr, width, parent=None):
		QWidget.__init__(self, parent)
		self.setLayout(QGridLayout(self))

		self.sim = sim
		self.addrSpace = addrSpace
		self.addr = addr
		self.width = width

	def get(self):
		pass

	def update(self):
		pass

class BitDisplayWidget(AbstractDisplayWidget):
	def __init__(self, sim, addrSpace, addr, width, parent=None):
		AbstractDisplayWidget.__init__(self, sim, addrSpace,
					       addr, width, parent)

		self.cbs = []
		for i in range(self.width):
			cb = QCheckBox(str(i), self)
			self.layout().addWidget(cb, 0, self.width - i - 1)
			self.cbs.append(cb)
			cb.stateChanged.connect(self.changed)

		self.update()

	def get(self):
		value = 0
		for i in range(self.width):
			if self.cbs[i].checkState() == Qt.Checked:
				value |= (1 << i)
		return value

	def update(self):
		try:
			oper = AwlOperator(self.addrSpace, self.width, self.addr)
			value = self.sim.getCPU().fetch(oper)
		except AwlSimError as e:
			QMessageBox.critical(self, "Failed to fetch",
				"Failed to fetch memory:\n" + str(e))
			return
		for i in range(self.width):
			if value & (1 << i):
				self.cbs[i].setCheckState(Qt.Checked)
			else:
				self.cbs[i].setCheckState(Qt.Unchecked)

class HexDisplayWidget(AbstractDisplayWidget):
	def __init__(self, sim, addrSpace, addr, width, parent=None):
		AbstractDisplayWidget.__init__(self, sim, addrSpace,
					       addr, width, parent)
		#TODO

		self.update()

	def get(self):
		pass#TODO

	def update(self):
		pass#TODO

class DecDisplayWidget(AbstractDisplayWidget):
	def __init__(self, sim, addrSpace, addr, width, parent=None):
		AbstractDisplayWidget.__init__(self, sim, addrSpace,
					       addr, width, parent)
		#TODO

		self.update()

	def get(self):
		pass#TODO

	def update(self):
		pass#TODO

class BinDisplayWidget(AbstractDisplayWidget):
	def __init__(self, sim, addrSpace, addr, width, parent=None):
		AbstractDisplayWidget.__init__(self, sim, addrSpace,
					       addr, width, parent)
		#TODO

		self.update()

	def get(self):
		pass#TODO

	def update(self):
		pass#TODO

class State_Mem(StateWindow):
	def __init__(self, sim, addrSpace, parent=None):
		StateWindow.__init__(self, sim, parent)
		name = AbstractDisplayWidget.addrspace2name[addrSpace]
		self.setWindowTitle(name)

		self.addrSpace = addrSpace

		self.addrSpin = QSpinBox(self)
		self.addrSpin.setPrefix(name + " ")
		self.layout().addWidget(self.addrSpin, 0, 0)

		self.widthCombo = QComboBox(self)
		self.widthCombo.addItem("Byte", 8)
		self.widthCombo.addItem("Word", 16)
		self.widthCombo.addItem("DWord", 32)
		self.layout().addWidget(self.widthCombo, 0, 1)

		self.fmtCombo = QComboBox(self)
		self.fmtCombo.addItem("Checkboxes", "cb")
		self.fmtCombo.addItem("Hexadecimal", "hex")
		self.fmtCombo.addItem("Decimal", "dec")
		self.fmtCombo.addItem("Dual", "bin")
		self.layout().addWidget(self.fmtCombo, 0, 2)

		self.contentLayout = QGridLayout()
		self.contentLayout.setContentsMargins(QMargins())
		self.layout().addLayout(self.contentLayout, 1, 0, 1, 3)

		self.contentWidget = None

		self.addrSpin.valueChanged.connect(self.rebuild)
		self.widthCombo.currentIndexChanged.connect(self.rebuild)
		self.fmtCombo.currentIndexChanged.connect(self.rebuild)

		self.__changeBlocked = 0
		self.rebuild()

	def rebuild(self):
		if self.contentWidget:
			self.contentLayout.removeWidget(self.contentWidget)
			self.contentWidget.deleteLater()
		self.contentWidget = None

		addr = self.addrSpin.value()
		index = self.fmtCombo.currentIndex()
		fmt = self.fmtCombo.itemData(index)
		index = self.widthCombo.currentIndex()
		width = self.widthCombo.itemData(index)

		if fmt == "cb":
			self.contentWidget = BitDisplayWidget(self.sim,
							      self.addrSpace,
							      addr, width, self)
			self.contentLayout.addWidget(self.contentWidget)
		elif fmt == "hex":
			self.contentWidget = HexDisplayWidget(self.sim,
							      self.addrSpace,
							      addr, width, self)
			self.contentLayout.addWidget(self.contentWidget)
		elif fmt == "dec":
			self.contentWidget = DecDisplayWidget(self.sim,
							      self.addrSpace,
							      addr, width, self)
			self.contentLayout.addWidget(self.contentWidget)
		elif fmt == "bin":
			self.contentWidget = BinDisplayWidget(self.sim,
							      self.addrSpace,
							      addr, width, self)
			self.contentLayout.addWidget(self.contentWidget)
		else:
			assert(0)
		self.contentWidget.changed.connect(self.__changed)
		self.update()

	def __changed(self):
		if self.__changeBlocked or not self.contentWidget:
			return
		value = self.contentWidget.get()
		addr = self.addrSpin.value()
		index = self.widthCombo.currentIndex()
		width = self.widthCombo.itemData(index)
		try:
			oper = AwlOperator(self.addrSpace, width, addr) 
			self.sim.getCPU().store(oper, value)
		except AwlSimError as e:
			QMessageBox.critical(self, "Failed to store",
				"Failed to store memory:\n" + str(e))
			return
		self.cpuStateChanged.emit()

	def update(self):
		if self.contentWidget:
			self.__changeBlocked += 1
			self.contentWidget.update()
			self.__changeBlocked -= 1
		StateWindow.update(self)

class StateWorkspace(QWorkspace):
	def __init__(self, parent=None):
		QWorkspace.__init__(self, parent)

class CpuWidget(QWidget):
	runStateChanged = Signal(bool)

	STATE_STOP	= 0
	STATE_RUN	= 1

	def __init__(self, mainWidget, parent=None):
		QWidget.__init__(self, parent)
		self.setLayout(QGridLayout(self))

		self.mainWidget = mainWidget
		self.state = self.STATE_STOP
		self.nextUpdate = 0.0

		group = QGroupBox("CPU status", self)
		group.setLayout(QGridLayout(group))
		self.runButton = QRadioButton("RUN", group)
		group.layout().addWidget(self.runButton, 0, 0)
		self.stopButton = QRadioButton("STOP", group)
		group.layout().addWidget(self.stopButton, 1, 0)
		self.layout().addWidget(group, 0, 0)

		group = QGroupBox("Add window", self)
		group.setLayout(QGridLayout(group))
		self.newCpuStateButton = QPushButton("CPU details", group)
		group.layout().addWidget(self.newCpuStateButton, 0, 0)
		self.newEButton = QPushButton("E", group)
		group.layout().addWidget(self.newEButton, 0, 1)
		self.newAButton = QPushButton("A", group)
		group.layout().addWidget(self.newAButton, 0, 2)
		self.newMButton = QPushButton("M", group)
		group.layout().addWidget(self.newMButton, 0, 3)
		self.layout().addWidget(group, 0, 1)

		self.stateWs = StateWorkspace(self)
		self.stateWs.setScrollBarsEnabled(True)
		self.layout().addWidget(self.stateWs, 1, 0, 1, 2)

		self.stopButton.setChecked(Qt.Checked)

		self.runButton.toggled.connect(self.__runStateToggled)
		self.stopButton.toggled.connect(self.__runStateToggled)
		self.newCpuStateButton.released.connect(self.__newWin_CPU)
		self.newEButton.released.connect(self.__newWin_E)
		self.newAButton.released.connect(self.__newWin_A)
		self.newMButton.released.connect(self.__newWin_M)

		self.update()

	def __addWindow(self, win):
		win.cpuStateChanged.connect(self.update)
		self.stateWs.addWindow(win, Qt.Window)
		win.show()
		self.update()

	def __newWin_CPU(self):
		self.__addWindow(State_CPU(self.mainWidget.getSim(), self))

	def __newWin_E(self):
		self.__addWindow(State_Mem(self.mainWidget.getSim(),
					   AbstractDisplayWidget.ADDRSPACE_E,
					   self))

	def __newWin_A(self):
		self.__addWindow(State_Mem(self.mainWidget.getSim(),
					   AbstractDisplayWidget.ADDRSPACE_A,
					   self))

	def __newWin_M(self):
		self.__addWindow(State_Mem(self.mainWidget.getSim(),
					   AbstractDisplayWidget.ADDRSPACE_M,
					   self))

	def update(self):
		for win in self.stateWs.windowList():
			win.update()

	def mayUpdate(self):
		now = time.time()
		if now < self.nextUpdate:
			return
		self.nextUpdate = now + 0.1
		self.update()

	def __run(self):
		sim = self.mainWidget.getSim()
		self.state = self.STATE_RUN
		self.runButton.setChecked(True)
		self.runButton.setEnabled(False) # Redraws the radio button
		self.runButton.setEnabled(True)
		ob1_awl = self.mainWidget.getCodeEditWidget().getCode()
		if not ob1_awl.strip():
			QMessageBox.critical(self, "No STL Code",
					     "No STL Code")
			self.stop()
			return
		try:
			parser = AwlParser()
			parser.parseData(ob1_awl)
			sim.load(parser.getRawInsns())
		except AwlSimError as e:
			QMessageBox.critical(self, "Simulator exception",
					     str(e))
			self.stop()
			return
		self.runStateChanged.emit(True)
		while self.state == self.STATE_RUN:
			try:
				QApplication.processEvents(QEventLoop.AllEvents, 1)
				sim.runCycle()
				self.mayUpdate()
			except AwlSimError as e:
				QMessageBox.critical(self, "Simulator exception",
						     str(e))
				self.stop()

	def stop(self):
		self.state = self.STATE_STOP
		self.stopButton.setChecked(True)
		self.runButton.setEnabled(True)
		self.runStateChanged.emit(False)

	def __runStateToggled(self):
		if self.runButton.isChecked():
			if self.state != self.STATE_RUN:
				self.__run()
		if self.stopButton.isChecked():
			if self.state != self.STATE_STOP:
				self.stop()

class EditWidget(QTextEdit):
	codeChanged = Signal()

	def __init__(self, parent=None):
		QTextEdit.__init__(self, parent)

		self.setFontFamily("Mono")

		self.__textChangeBlocked = 0
		self.textChanged.connect(self.__textChanged)

	def __textChanged(self):
		if self.__textChangeBlocked:
			return
		self.codeChanged.emit()

	def loadCode(self, code):
		self.__textChangeBlocked += 1
		self.setPlainText(code)
		self.__textChangeBlocked -= 1

	def getCode(self):
		return self.toPlainText()

class MainWidget(QWidget):
	dirtyChanged = Signal(bool)
	runStateChanged = Signal(bool)

	def __init__(self, parent=None):
		QWidget.__init__(self, parent)
		self.setLayout(QGridLayout(self))

		self.sim = AwlSim()

		self.codeEdit = EditWidget(self)
		self.layout().addWidget(self.codeEdit, 0, 0)

		self.cpuWidget = CpuWidget(self, self)
		self.layout().addWidget(self.cpuWidget, 0, 1)

		self.filename = None
		self.dirty = False

		self.codeEdit.codeChanged.connect(self.__codeChanged)
		self.cpuWidget.runStateChanged.connect(self.__runStateChanged)

	def __runStateChanged(self, running):
		self.codeEdit.setReadOnly(running)
		self.runStateChanged.emit(running)

	def getSim(self):
		return self.sim

	def getCodeEditWidget(self):
		return self.codeEdit

	def getCpuWidget(self):
		return self.cpuWidget

	def __codeChanged(self):
		self.dirty = True
		self.dirtyChanged.emit(self.dirty)

	def loadFile(self, filename):
		try:
			fd = open(filename, "r")
			code = fd.read()
			fd.close()
		except IOError as e:
			QMessageBox.critical(self,
				"File read failed",
				"File read failed:\n" +\
				str(e))
			return False
		self.codeEdit.loadCode(code)
		self.filename = filename
		return True

	def load(self):
		fn, fil = QFileDialog.getOpenFileName(self,
			"Open STL source", "",
			"STL source (*.awl);;"
			"All files (*)")
		if not fn:
			return
		self.loadFile(fn)

	def saveFile(self, filename):
		if not self.filename:
			return
		code = self.codeEdit.getCode()
		try:
			# TODO write then move
			fd = open(filename, "w")
			fd.write(code)
			fd.flush()
			fd.close()
		except IOError as e:
			QMessageBox.critical(self,
				"Failed to write file",
				"Failed to write file:\n" +\
				str(e))
			return False
		self.dirty = False
		self.dirtyChanged.emit(self.dirty)
		return True

	def save(self, newFile=False):
		if newFile:
			fn, fil = QFileDialog.getSaveFileName(self,
				"STL source save as", "",
				"STL source (*.awl);;")
			if not fn:
				return
			if not fn.endswith(".awl"):
				fn += ".awl"
			self.saveFile(fn)
		else:
			if not self.filename:
				return
			self.saveFile(self.filename)

class MainWindow(QMainWindow):
	def __init__(self):
		QMainWindow.__init__(self)

		self.setWindowTitle("S7 STL simulator")
		self.setCentralWidget(MainWidget(self))

		self.setMenuBar(QMenuBar(self))

		menu = QMenu("&File", self)
		menu.addAction("&Open...", self.load)
		self.saveAct = menu.addAction("&Save", self.save)
		menu.addAction("&Save as...", self.saveAs)
		menu.addSeparator()
		menu.addAction("&Exit...", self.close)
		self.menuBar().addMenu(menu)

		menu = QMenu("Help", self)
		menu.addAction("&About...", self.about)
		self.menuBar().addMenu(menu)

		self.tb = QToolBar(self)
		self.tb.addAction("Open", self.load)
		self.tbSaveAct = self.tb.addAction("Save", self.save)
		self.addToolBar(self.tb)

		self.__dirtyChanged(False)

		self.centralWidget().dirtyChanged.connect(self.__dirtyChanged)
		self.centralWidget().runStateChanged.connect(self.__runStateChanged)

		if len(sys.argv) > 1:
			self.centralWidget().loadFile(sys.argv[1])

	def __runStateChanged(self, running):
		self.menuBar().setEnabled(not running)
		self.tb.setEnabled(not running)

	def __dirtyChanged(self, isDirty):
		self.saveAct.setEnabled(isDirty)
		self.tbSaveAct.setEnabled(isDirty)

	def closeEvent(self, ev):
		self.centralWidget().getCpuWidget().stop()
		ev.accept()

	def about(self):
		QMessageBox.information(self, "About S7 STL simulator",
			"awlsim\n\n"
			"Copyright 2012 Michael Büsch <m@bues.ch>\n"
			"Licensed under the terms of the "
			"GNU GPL version 2.")

	def load(self):
		self.centralWidget().load()

	def save(self):
		self.centralWidget().save()

	def saveAs(self):
		self.centralWidget().save(True)

def main():
	app = QApplication(sys.argv)
	mainwnd = MainWindow()
	mainwnd.show()
	return app.exec_()

if __name__ == "__main__":
	sys.exit(main())
